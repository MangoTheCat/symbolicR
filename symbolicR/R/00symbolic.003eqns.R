#' analyse.0.0
#'
#' After dividing up the graph into connected.components, 
#' we do \code{\link{analyse.connected.component.critical.points}} on each one for extracting pk variables definitions.
#' for other unknown variables, currently we just keep them as is.
#' We may add more code for analysing those part(the other part) in future.
#' @param eqns equations
#' @param ... extra.rules
#' @return the found definitions for pk variables, and other non-pk definitions are kept as is
analyse.0.0 = function(eqns, ...){
    gg = create.abstractGraph.from.equations(eqns)
    # divided up into connected.components
    cps = divide.graph(gg$graph)
    analysed.defns = list()
    other.rels = list()
    for(i in 1:length(cps)){
        component.eqns.ind = unique(gg$backref[ restriction.morphism.of.graph.at.v(gg$graph, cps[[i]]) ] )
        if (length(component.eqns.ind)==0) {
            stop('Detect a component without equation reference, 
                  might be caused by an isolated constant initialization.')
        }
        foo = analyse.connected.component.critical.points(
        # this will remove those initialization of a tempvariable
        # e.g. `TEMP[1][Q]` = 1
        # and there is no edges corresponding to this equation in the graph
        # and it disappears
        # to avoid this, we should ensure the passed in eqns has removed those initialization lines
            eqns[ component.eqns.ind ] , ...)
        if(length(foo$critical.relations)>0) {
            analysed.defns[[ length(analysed.defns)+1 ]] = foo$critical.relations
        }
        if(length(foo$left.eqns)>0){
            other.rels = c(other.rels, foo$left.eqns)
        }
    }
    list(analysed.defns=analysed.defns, other.rels=other.rels)
}

#' analyse.connected.component.critical.points
#'
#' The working horse for \code{analyse.connected.component.critical.points}
#' combind \code{topo.sort},
#' \code{get.definition.of.v},
#' and use \code{pattern.distrib.*}
#' to analysis to some extent general equations
#' assuming eqns are connected.component
#' Try to figure out the meaning of the critical points in the connected component
#' And return the left ind of the eqns
#' if no PK lhs is found, return just the left inds
#' @param eqns equations
#' @param socp set of critical points, critical points should be an lhs, and is necessary for its offsprins critical points
#' @param extra.rules also allow to add a list of pattern and actions to extend the functionality of this function
#' @param skip.patterns if skip pattern matchers
#' @param ... other parameters may be passed to the pattern functions
#' @return information on variability
analyse.connected.component.first.critical.points = function(eqns,socp,extra.rules=NULL,skip.patterns=FALSE, ...) {
    gg = create.abstractGraph.from.equations(eqns)
    ind0 = topo.sort(gg$graph)

    variables = gg$vertex.table
    ind.socp = match.symbolic(socp, variables)
    ind.socp = ind.socp[ complete.cases(ind.socp) ]
    # This gg is generated by a subset eqns than the whole graph, 
    # the critical point for this eqn must be again a lhs in this gg, not only the hence original gg
    ind.socp = intersect(gg$lhs.ind, ind.socp)
    if (length(ind.socp)==0) {
        return( list(seq_along(eqns), 
                list(critical.varname=as.symbol(NA),
                    type='not found',
                    defn=NULL),
                    depend.on=NULL
                    ))
    }
    # find pk's, in a topological order 
    v0 = gg$vertex.table[[ as.integer((ind0$L[ ind0$L %in% ind.socp ])[1]) ]]
    defn = get.definition.of.v(eqns, v0)
    # match patterns one by one
    # random variable from theta's, which cost degree of freedom
    if (!skip.patterns) {
        pat = pattern.distrib.normal(defn$final.e, ...)
        # simulate swith-case
        if(!is.null(pat)){
            return(list(defn$ind,list(
                critical.varname=v0, 
                type='directly.related.to.nonmem.parameters',
                defn=pat), 
                depend.on = defn$depend.on
                ))
        }
        # random variable from theta's, which cost degree of freedom
        pat = pattern.distrib.lognormal(defn$final.e, ...)
        if(!is.null(pat)){
            return(list(defn$ind,list(
                critical.varname=v0, 
                type='directly.related.to.nonmem.parameters',
                defn=pat),
                depend.on = defn$depend.on
                ))
        }
    }
    # depend on previously, not directly on theta's, eta's
    if(!list.any.is.nonmem.par(defn$depend.on)){
        return(list(defn$ind,list(
            critical.varname=v0,
            type='related.on.previous.variables',
            defn=defn$final.e),
            depend.on = defn$depend.on
            ))
    }
    pat = pattern.distrib.fixed(defn$final.e)
    if(!is.null(pat)){
        return(list(defn$ind,list(
            critical.varname=v0, 
            type='directly.related.to.nonmem.parameters',
            defn=pat),
            depend.on = defn$depend.on
            ))
    }
    if (!is.null(extra.rules) && is.list(extra.rules) && length(extra.rules)>0) {
        for(rule in extra.rules){
            if (!is.null(pat <- rule$pat(defn))) {
                re = list(defn$ind, 
                            rule$action(defn,pat),
                        depend.on=defn$depend.on)
                re[[2]]$critical.varname=v0
                return(re)
            }
        }
    }
    return(list(defn$ind,list(
        critical.varname=v0,
        type='unknown',
        defn=defn$final.e),
        depend.on = defn$depend.on
        ))
}

#' analyse.connected.component.first.critical.points
#' 
#' for a connected component, try to extract PK variables (as lhs) one by one
#' If no pk variables found, return eqns as is
#' actually, what we can get are not PK variables, but however the critical point varibles
#'
#' @param eqns
#' @param ... extra.rules
#' @return found pk relations and left equations(might be for other use)
analyse.connected.component.critical.points = function(eqns, socp.filter=socp.filter.default, ...){
    gg = create.abstractGraph.from.equations(eqns)
    variables = gg$vertex.table
    socp.ind = socp.filter(gg=gg, variables=variables, eqns=eqns)
    # them, iterating increasing the socp set
    if (length(socp.ind)==0) {
    # If component has no pk variables, return them as is
        return(list(
            critical.relations=list(),
            left.eqns=eqns))
    }
    # init iter.variables
    re = list()
    left.eqns = list()
    eqns.iter = eqns
    while(length(eqns.iter)>0){
        foo = analyse.connected.component.first.critical.points(eqns.iter, variables[socp.ind], ...)
        # if new sections depend on :
        # variable as a lhs,
        #             not in socp,
        #             not a nonmem.parameter
        # this variable should be appended in socp
        if (foo[[2]]$type=='not found'){
            left.eqns = c(left.eqns, eqns.iter[ foo[[1]] ])
            break()
        }
        dep.ind = match.symbolic(foo$depend.on, variables)
        dep.ind = intersect( dep.ind, gg$lhs.ind )
        dep.ind = setdiff(dep.ind, socp.ind)
        if (length(dep.ind) > 0 ) {
            socp.ind = union(socp.ind, dep.ind)
            # if critical points changed, need restart
            re = list()
            left.eqns = list()
            eqns.iter = eqns
            next()
        }
        re[[ length(re)+1 ]]=foo[[2]]
        eqns.iter = eqns.iter[ -foo[[1]] ]
    }
    list(critical.relations=re,left.eqns=left.eqns)
}

#' get.definition.of.v
#'
#' find necessary equations for a given variable
#' @param eqns equations
#' @param vn symbol of variable
#' @return evaluated value of \code{vn} using \code{eqns} and the depending variables
get.definition.of.v = function(eqns,vn){
    env0 = new.env(parent=emptyenv())
    # Note:
    # This simple stratigy can't handle IF/THEN/ELSE correctly
    # e.g. 
    #  Q = 1
    # IF (MIXNUM==2) Q=2
    # actually Q = f(MIXNUM)
    # However, if we use the eval.symbolic, Q is evaluated to 0
    # and the warning equations has more relations than in subgraph will happen, 
    # because Q disappears from subgraph of vn.expression
    # two ways of fixing this
    # (1) add a translations layer to change the IF statements to a function 
    # (2) or change the eval.symbolic to correctly handle the IF
    eval.symbolic(eqns, env0)
    gg = create.abstractGraph.from.equations(eqns)
    vn.expression = eval.symbolic(vn, env0)
    vn.rhs = extract.vertices(vn.expression)$rhs.symbol
    vn.rhs.ind = match.symbolic(vn.rhs, gg$vertex.table)
    vn.ind = match.symbolic(vn, gg$vertex.table)
    G = gg$graph
    subg.of.vn = intersect(
                    connected.component(G, vn.rhs.ind, direction=1),
                    connected.component(G, vn.ind,     direction=0))
    ind = unique(gg$backref[ restriction.morphism.of.graph.at.v(G,subg.of.vn) ])
    re = integer(0)
    for(i in ind){
        if (! all(gg$eqns.vertex[[ i ]] %in% subg.of.vn) ){
            warning(sprintf('Equation: %s has more relations than in subgraph, will be dropped!', paste(deparse(eqns[[i]]),collapse=' ')))
        } else {
            re = c(re, i)
        }
    }
    list(final.e=vn.expression,
         depend.on=vn.rhs,
         intermediate=gg$vertex.table[setdiff(subg.of.vn, union(vn.ind, vn.rhs.ind))],
         ind = re)
}
